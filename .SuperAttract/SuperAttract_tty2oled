#!/bin/bash
compgen -v | sed s/=.\*// >/tmp/$$

# https://github.com/mrchrisster/MiSTer_SAM/
# Copyright (c) 2021 by mrchrisster and Mellified

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# Description
# This cycles through arcade and console cores periodically
# Games are randomly pulled from their respective folders

# ======== Credits ========
# Original concept and implementation: mrchrisster
# Additional development and script layout: Mellified and Paradox
#
# mbc by pocomane
# partun by woelper
# samindex by wizzo
# tty2oled by venice
#
# Thanks for the contributions and support:
# kaloun34, redsteakraw, RetroDriven, LamerDeluxe, InquisitiveCoder, Sigismond

#!/bin/bash

# https://github.com/mrchrisster/MiSTer_SAM/
# Copyright (c) 2021 by mrchrisster and Mellified

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# Description
# This cycles through arcade and console cores periodically
# Games are randomly pulled from their respective folders

# ======== Credits ========
# Original concept and implementation: mrchrisster
# Additional development and script layout: Mellified and Paradox
#
# mbc by pocomane
# partun by woelper
# samindex by wizzo
# tty2oled by venice
#
# Thanks for the contributions and support:
# kaloun34, redsteakraw, RetroDriven, LamerDeluxe, InquisitiveCoder, Sigismond
trap '' INT

# ======== GLOBAL VARIABLES =========
declare -g misterpath="/media/fat"
declare -g misterscripts="${misterpath}/Scripts"
declare -g mrsampath="${misterscripts}/.SuperAttract"
if [ -s SuperAttractSystem ]; then
	source SuperAttractSystem
elif [ -s ${mrsampath}/SuperAttractSystem ]; then
	source ${mrsampath}/SuperAttractSystem
else
	echo "Error! SuperAttractSystem not found!"
	exit
fi

trap 'rc=$?;[ ${rc} = 0 ] && exit;tty_exit' EXIT TERM

startup_tasks

# ======== FUNCTIONS ========
function start_pipe_reader() {
	samquiet " Init tty2oled, starting pipe reader... "
	[ -p ${TTY_cmd_pipe} ] && rm -f ${TTY_cmd_pipe}
	[ -e ${TTY_cmd_pipe} ] && rm -f ${TTY_cmd_pipe}
	if [[ ! -p ${TTY_cmd_pipe} ]]; then
		mkfifo ${TTY_cmd_pipe}
	fi

	while true; do
		local line
		if [[ -p ${TTY_cmd_pipe} ]]; then
			if read line <${TTY_cmd_pipe}; then
				set -- junk ${line}
				shift
				case "${1}" in
				stop | quit | exit)
					tty_exit
					break
					;;
				display_info)
					shift
					tty_display "${@}"
					;;
				update_counter)
					update_counter
					;;
				*)
					echo " ERROR! ${line} is unknown."
					echo " Try $(basename -- ${0}) help"
					echo " Or check the Github readme."
					echo " Named Pipe"
					;;
				esac
			fi
		fi
	done &
}

# ======== tty2oled FUNCTIONS ========

function tty_init() { # tty_init
	# tty2oled initialization
	declare -gi START=$(date +%s)
	samquiet " Init tty2oled, loading variables... "
	source ${ttysystemini}
	source ${ttyuserini}
	ttydevice=${TTYDEV}
	ttypicture=${picturefolder}
	ttypicture_pri=${picturefolder_pri}
	set_scroll_speed

	# Stopping tty2oled Daemon
	if [ -f /tmp/tty2oled_sleep ]; then
        sleepfile_creation=$(</tmp/tty2oled_sleep)
        sleepfile_age=$((EPOCHSECONDS - sleepfile_creation))
        samdebug "! $sleepfile_creation ! $sleepfile_age !"
        if [ ${sleepfile_age} -lt "${gametimer}" ]; then
 			write_to_TTY_cmd_pipe "display_info" &
		else
			rm /tmp/tty2oled_sleep
		fi
	fi
	if [ ! -f /tmp/tty2oled_sleep ]; then
		samquiet "-n" " Stopping tty2oled Daemon..."
		echo "$EPOCHSECONDS" > /tmp/tty2oled_sleep
		samquiet " Done!"

		# Clear Serial input buffer first
		samquiet "-n" " Clear tty2oled Serial Input Buffer..."
		while read -t 0 sdummy <${ttydevice}; do continue; done
		samquiet " Done!"

		# Stopping ScreenSaver
		samquiet "-n" " Stopping tty2oled ScreenSaver..."
		echo "CMDSAVER,0,0,0" >${ttydevice}
		tty_waitfor
		samquiet " Done!"

		echo "CMDAPD,SAM_splash" >/dev/ttyUSB0
		tail -n +4 "/media/fat/Scripts/.SuperAttract/SAM_splash.gsc" | xxd -r -p >/dev/ttyUSB0
		tty_waitfor
		echo "CMDSPIC,-1" >/dev/ttyUSB0
		sleep 5
	fi
	if [ "${samdebug}" == "yes" ]; then
		vardebug_out
	fi
}

function tty_exit() {
	samquiet "-n" " Starting tty2oled Daemon..."
	[ -f /tmp/tty2oled_sleep ] && rm /tmp/tty2oled_sleep &>/dev/null
	samquiet " Done!"
	# Clear Display	with Random effect
	echo "CMDCLST,-1,0" >${ttydevice}
	tty_waitfor
	echo "CMDBYE" >${ttydevice}
	sleep 5
	tty_cleanup
}

function tty_waitfor() {
	read -t 10 -d ";" ttyresponse <${ttydevice} # Read now with Timeout and without "loop"
	ttyresponse=""
}

function update_loop() {
	while [[ -p ${TTY_cmd_pipe} ]]; do
		sleep 1
		write_to_TTY_cmd_pipe "update_counter" &
	done
}

function set_scroll_speed() {
	ttyscroll_speed_int=$((${ttyscroll_speed} - 1))
}

function update_name_scroll() {
	if [ ${ttyscroll_speed} -gt 0 ]; then
		if [ ${#tty_currentinfo[name]} -gt 21 ]; then
			if [ ${ttyscroll_speed_int} -gt 0 ]; then
				((ttyscroll_speed_int--))
			else
				set_scroll_speed
				if [ ${tty_currentinfo[name_scroll_direction]} -eq 1 ]; then
					if [ ${tty_currentinfo[name_scroll_position]} -lt $((${#tty_currentinfo[name]} - 21)) ]; then
						((tty_currentinfo[name_scroll_position]++))
					else
						tty_currentinfo[name_scroll_direction]=0
					fi
				elif [ ${tty_currentinfo[name_scroll_direction]} -eq 0 ]; then
					if [ ${tty_currentinfo[name_scroll_position]} -gt 0 ]; then
						((tty_currentinfo[name_scroll_position]--))
					else
						tty_currentinfo[name_scroll_direction]=1
					fi
				fi
				tty_currentinfo[name_scroll]="${tty_currentinfo[name]:${tty_currentinfo[name_scroll_position]}:21}"
				echo "CMDTXT,103,0,0,0,20,${prev_name_scroll}" >${ttydevice}
				echo "CMDTXT,103,15,0,0,20,${tty_currentinfo[name_scroll]}" >${ttydevice}
				prev_name_scroll="${tty_currentinfo[name_scroll]}"
			fi
		fi
	fi
}

function update_counter() {
	if [ ${tty_currentinfo[update_pause]} -gt 0 ]; then
		((tty_currentinfo[update_pause]--))
	else
		update_name_scroll
	fi
	local elapsed=$((EPOCHSECONDS - tty_currentinfo[date]))
	tty_currentinfo[counter]=$((gametimer - elapsed))
	if [ ${tty_currentinfo[counter]} -lt 1 ]; then
		tty_currentinfo[counter]=0
	fi
	echo "CMDTXT,102,0,0,0,60,Next game in ${prev_counter}" >${ttydevice}
	echo "CMDTXT,102,15,0,0,60,Next game in ${tty_currentinfo[counter]}" >${ttydevice}
	prev_counter="${tty_currentinfo[counter]}"
	echo "CMDDUPD" >"${ttydevice}"
	tty_waitfor
	if [ ${samtrace} == "yes" ]; then
		declare -p tty_currentinfo | sed 's/declare -A tty_currentinfo=//g'
	fi
}

function tty_display() { # tty_update core game
	echo "$EPOCHSECONDS" > /tmp/tty2oled_sleep
	source "${tty_currentinfo_file}"
	# Wait for tty2oled daemon to show the core logo
	tty_senddata "${tty_currentinfo[core]}"
	# Wait for tty2oled to show the core logo
	samdebug "-------------------------------------------"
	samdebug " tty_update got Corename: ${tty_currentinfo[core]} "
	# Show Core-Logo for 5 Secs
	sleep 5
	# Clear Display	with Random effect
	echo "CMDCLST,-1,0" >"${ttydevice}"
	tty_waitfor
	local elapsed=$((EPOCHSECONDS - tty_currentinfo[date]))
	tty_currentinfo[counter]=$((gametimer - elapsed))
	echo "CMDTXT,103,15,0,0,20,${tty_currentinfo[name_scroll]}" >${ttydevice}
	echo "CMDTXT,102,5,0,0,40,${tty_currentinfo[core_pretty]}" >${ttydevice}
	echo "CMDTXT,102,15,0,0,60,Next game in ${tty_currentinfo[counter]}" >${ttydevice}
	prev_name_scroll="${tty_currentinfo[name_scroll]}"
	prev_counter="${tty_currentinfo[counter]}"
}

# USB Send-Picture-Data function
function tty_senddata() {
	local newcore="${1}"
	unset picfnam
	if [ -e "${ttypicture_pri}/${newcore}.gsc" ]; then # Check for _pri pictures
		picfnam="${ttypicture_pri}/${newcore}.gsc"
	elif [ -e "${ttypicture_pri}/${newcore}.xbm" ]; then
		picfnam="${ttypicture_pri}/${newcore}.xbm"
	else
		picfolders="gsc_us xbm_us gsc xbm xbm_text" # If no _pri picture found, try all the others
		[ "${USE_US_PICTURE}" = "no" ] && picfolders="${picfolders//gsc_us xbm_us/}"
		[ "${USE_GSC_PICTURE}" = "no" ] && picfolders="${picfolders//gsc_us/}" && picfolders="${picfolders//gsc/}"
		[ "${USE_TEXT_PICTURE}" = "no" ] && picfolders="${picfolders//xbm_text/}"
		for picfolder in ${picfolders}; do
			for ((c = "${#newcore}"; c >= 1; c--)); do                                 # Manipulate string...
				picfnam="${ttypicture}/${picfolder^^}/${newcore:0:${c}}.${picfolder:0:3}" # ...until it matches something
				[ -e "${picfnam}" ] && break
			done
			[ -e "${picfnam}" ] && break
		done
	fi
	if [ -e "${picfnam}" ]; then # Exist?
		# For testing...
		samdebug "-------------------------------------------"
		samdebug " tty2oled sending Corename: ${1} "
		samdebug " tty2oled found/send Picture : ${picfnam} "
		samdebug "-------------------------------------------"

		echo "CMDCOR,${1}" >"${ttydevice}"                # Send CORECHANGE" Command and Corename
		tail -n +4 "${picfnam}" | xxd -r -p >${ttydevice} # The Magic, send the Picture-Data up from Line 4 and proces
		tty_waitfor                                       # sleep needed here ?!
	else                                               # No Picture available!
		echo "${1}" >"${ttydevice}"                       # Send just the CORENAME
		tty_waitfor                                       # sleep needed here ?!
	fi                                                 # End if Picture check
}

# ========= TTY MONITOR =========
function tty_monitor_new() {
	# We can omit -r here. Tradeoff;
	# window size size is correct, can disconnect with ctrl-C but ctrl-C kills MCP
	# tmux attach-session -t SAM
	# window size will be wrong/too small, but ctrl-c nonfunctional instead of killing/disconnecting
	tmux attach-session -t TTY
}

# ========= MAIN =========
function main() {
	start_pipe_reader
	tty_init
	update_loop
}

if [ "${ttyenable}" == "yes" ]; then
	main ${@}
fi
trap - INT
